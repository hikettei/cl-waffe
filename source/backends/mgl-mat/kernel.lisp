
(in-package :cl-waffe.backends.mgl)

; Todo Rewrite with define-lisp-kernel

(defmacro duplicate-tensor (mat)
  `(let ((o (mgl-mat:make-mat (mgl-mat:mat-dimensions ,mat))))
     (mgl-mat:copy! ,mat o)
     o))

(defmacro apply-destruct (out)
  `(progn ; tensor=out
     (setf (waffetensor-is-data-destructed? ,out) t)
     (setf (waffetensor-destructively-calln ,out) 1)))

(defmacro assure-destructed? (out tensor)
  `(progn
     (unless (waffetensor-destructive? ,tensor)
       (error "Kernel Error: Modifying tensor that is not allowed to destruct"))
     ,out))

(defmacro decide-out-buffer (out args var enable-optim)
  `(progn
     (apply-destruct ,var)
     (if ,out
	 (progn
	   (if (and ,enable-optim (waffetensor-destructive? ,out))
	       (assure-destructed? (data ,out) ,var)
	       (duplicate-tensor (assure-destructed? ,args ,var))))
	 (duplicate-tensor (assure-destructed? ,args ,var)))))

;(declaim (ftype (function (mgl-mat:mat fixnum) mgl-mat:mat) repeat))
(defun repeat (tensor n &key axis)
;  (declaim (optimize (speed 3) (safety 0) (debug 0))
;	   (type mgl-mat:mat tensor)
;	   (type fixnum n axis))
  (if (typep tensor 'mgl-mat:mat)
      (if axis
	  (if (>= (length (mgl-mat:mat-dimensions tensor)) 2)
              (mgl-mat:stack axis (loop for i below n collect tensor))
	      (repeat (mgl-mat:reshape tensor `(,@(mgl-mat:mat-dimensions tensor) 1)) n :axis axis))
	  (error "axis=-1"))
      (error "array != mat")))

;(declaim (ftype (function (mgl-mat:mat waffesupporteddatatype) mgl-mat:mat) trasposedmgl-full-like mgl-full-like))
(defun mgl-full-like (tensor value)
;  (declare (optimize (speed 3) (safety 0) (debug 0))
;	   (type mgl-mat:mat tensor)
;	   (type waffesupporteddatatype value))
  (mgl-mat:make-mat (mgl-mat:mat-dimensions tensor)
		    :initial-element value))

(defun transposed-mgl-full-like (tensor value)
;  (declare (optimize (speed 3) (safety 0) (debug 0))
;	   (type mgl-mat:mat tensor)
;	   (type waffesupporteddatatype value))
  (let ((dims (mgl-mat:mat-dimensions tensor)))
    (declare (type cons dims))
    (mgl-mat:make-mat (reverse dims)
		      :initial-element value)))

(defparameter *v2v-operations* `(:add :sub :mul :div :dot :matmul))
(defparameter *abort-delay-instruction* :matmul)

(defmacro deliv-delay (tensor func &rest args)
  `(lambda (shape? step?)
     (if shape?
	 (reverse (mgl-mat:mat-dimensions ,tensor))
	 (if step?
	     (funcall ,func ,tensor ,@args) ; receive before node
	     ,tensor)))) ; abort before node

(defmacro next-delay (delay state)
  `(if (typep ,delay 'function)
       (funcall ,delay nil ,state)
       ,delay))

(defmacro abort-delay (delay)
  `(next-delay ,delay nil))

(defmacro receive-delay (delay)
  `(next-delay ,delay t))

(defun ensure-shape (ope args)
  (if (find ope *v2v-operations*)
      (let ((m (find 'mgl-mat:mat args :test (lambda (x y) (typep y x)))))
	(unless m (error "Waffe Kernel Error"))
	(map 'list (lambda (x)
		     (if (or (typep x 'mgl-mat:mat) (typep x 'function))
			 (if (eq ope *abort-delay-instruction*)
			     (abort-delay x)
			     (receive-delay x))
			 (if (eq ope :matmul)
			     (transposed-mgl-full-like m x)
			     (mgl-full-like m x))))
	     args))
      ; suppose that args has at least 1 mats.
      args))

(defun infomation ())

(defun add-scalar (enable-optimize? out x y)
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (if (typep (data x) 'mgl-mat:mat)
      (let ((o (decide-out-buffer out (data x) out enable-optimize?)))
	(mgl-mat:.+! (data y) o))
      (let ((o (decide-out-buffer out (data y) out enable-optimize?)))
	(mgl-mat:.+! (data x) o))))


(defun sub-scalar (enable-optimize? out x y)
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (if (typep (data x) 'mgl-mat:mat)
      (let ((o (decide-out-buffer out (data x) out enable-optimize?)))
	(mgl-mat:.+! (* -1.0 (data y)) o))
      (let ((o (decide-out-buffer out (data y) out enable-optimize?)))
	(mgl-mat:.+! (data x)
		     (mul-tensor enable-optimize? out out y (const -1.0))))))
      
(defun add-tensor (enable-optimize? out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optimize?)
	   (type waffetensor out x y))
  (if (or (not (typep (data x) 'mgl-mat:mat))
	  (not (typep (data y) 'mgl-mat:mat)))
      (add-scalar enable-optimize? out x y)
      (if (eq (mgl-mat:mat-dimensions (data x)) (mgl-mat:mat-dimensions (data y)))
	  (let ((o (mgl-mat:make-mat (mgl-mat:mat-dimensions (data x)))))
	    (mgl-mat:axpy! 1.0 (data x) o)
	    (mgl-mat:axpy! 1.0 (data y) o)
	    o)
	  (mgl-mat:m+ (data x) (data x)))))

(defun sub-tensor (enable-optimize? out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optimize?)
	   (type waffetensor out x y))
  (if (or (not (typep (data x) 'mgl-mat:mat))
	  (not (typep (data y) 'mgl-mat:mat)))
      (sub-scalar enable-optimize? out x y)
      (if (eq (mgl-mat:mat-dimensions (data x)) (mgl-mat:mat-dimensions (data y)))
	  (let ((o (mgl-mat:make-mat (mgl-mat:mat-dimensions (data x)))))
	    (mgl-mat:axpy! 1.0  (data x) o)
	    (mgl-mat:axpy! -1.0 (data y) o)
	    o)
	  (mgl-mat:m- (data x) (data y)))))

(defun mul-tensor (enable-optimize? out out1 x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (ignore out)
	   (type boolean enable-optimize?)
	   (type waffetensor out out1 x y))
  
  (if (or (not (typep (data x) 'mgl-mat:mat))
	  (not (typep (data y) 'mgl-mat:mat)))
      (let* ((alpha (if (typep (data x) 'mgl-mat:mat)
			(data y)
			(data x)))
	     (o     (if (typep (data x) 'mgl-mat:mat)
			(decide-out-buffer out (data x) out  enable-optimize?)
			(decide-out-buffer out (data y) out1 enable-optimize?))))
	(mgl-mat:scal! alpha o)
	o)
      (let ((o (mgl-mat:make-mat (mgl-mat:mat-dimensions (data x)))))
	(mgl-mat:geem! 1 (data x) (data y) 0 o)
	o)))


(defun div-tensor (enable-optimize? out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optimize?)
	   (type waffetensor out x y))
  (let* ((o   (mgl-mat:make-mat (mgl-mat:mat-dimensions (data y))))
	 (inv (inv-tensor enable-optimize? out y)))
    (mgl-mat:scal! (data x) inv)))

(defun dot-tensor (enable-optimize? out x y)
  (declare (ignore enable-optimize? out))
  (mgl-mat:dot (data x) (data y)))

(defun matmul-tensor (enable-optimize? o x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (ignore o)
	   (type boolean enable-optimize?)
	   (type waffetensor o))

  (let ((transpose-map `(,(typep (data x) 'function) ,(typep (data y) 'function)))
	(out (mgl-mat:make-mat `(,(if (car transpose-map)
				      (car  (reverse (mgl-mat:mat-dimensions (data (car args)))))
				      (car  (mgl-mat:mat-dimensions (data (car args)))))
				 ,(if (second transpose-map)
				      (second (reverse (mgl-mat:mat-dimensions (data (second args)))))
				      (second (mgl-mat:mat-dimensions (data (second args)))))))))
    (unless (and (<= (length (mgl-mat:mat-dimensions (data (car args)))) 2)
		 (<= (length (mgl-mat:mat-dimensions (data (second args)))) 2))
      (error "cl-waffe.backends.mgl: :matmul failed due to unsatisfied with (!dims a) <= 2 and (!dims b) <= 2"))
    (mgl-mat:gemm! 1 (data (car args)) (data (second args)) 0 out :transpose-a? (car transpose-map) :transpose-b? (second transpose-map))
    out))

(defun log-tensor (enable-optim out x)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
           (mgl-mat:.log! o)))


(defun exp-tensor (enable-optim out x)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
    (mgl-mat:.exp! o)))

(defun inv-tensor (enable-optim out x)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
           (mgl-mat:.inv! o)))

(defun sqrt-tensor (enable-optim out x)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
           (mgl-mat:.sqrt! o)))

(defun pow-tensor (enable-optim out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x y))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
    (mgl-mat:.expt! o (data y))))

(defun tanh-tensor (enable-optim out x)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
       (mgl-mat:.tanh! o)))

(defun compare-tensor (enable-optim out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optim)
           (type waffetensor out x y))
  (let ((o (decide-out-buffer out (data x) out enable-optim)))
           (mgl-mat:.<! y x)))

(defun sum-tensor (is-first-time-call? out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
           (type boolean is-first-time-call?)
           (type waffetensor out x y))

  (let* ((dims (mgl-mat:mat-dimensions (data x)))
	 (dims (if (and (= 1 (car (last dims)))
			(= 3 (length dims)))
		   (butlast dims)
		   dims))
	 (x (mgl-mat:reshape! (mgl-mat:copy-mat (data x)) dims))
	 (dims (case (data y)
		 (1 `(,@(list (car dims)) 1))
		 (0 `(1 ,@(cdr dims)))
		 (T (error "Sum only supports a 2d matrix")))))
    (let ((o (mgl-mat:make-mat dims :initial-element 0)))
      (mgl-mat:sum! x o :axis (data y) :beta 1)
      (mgl-mat:reshape! o dims)
      (if (equal dims `(1 1))
	  (mgl-mat:mref o 0 0)
	  o))))

(defun mean-tensor (is-first-time-call? out x y) ; =sum?????
  (declare (optimize (speed 3) (space 0) (safety 0))
           (type boolean is-first-time-call?)
           (type waffetensor out x y))

  (let* ((dims (mgl-mat:mat-dimensions (data x)))
	 (dims (if (and (= 1 (car (last dims)))
			(= 3 (length dims)))
		   (butlast dims)
		   dims))
	 (x (mgl-mat:reshape! (mgl-mat:copy-mat (data x)) dims))
	 (dims (case (data y)
		 (1 `(,@(list (car dims)) 1))
		 (0 `(1 ,@(cdr dims)))
		 (T (error "Sum only supports a 2d matrix")))))
    (let ((o (mgl-mat:make-mat dims :initial-element 0)))
      (mgl-mat:sum! x o :axis (data y) :beta 1)
      (mgl-mat:reshape! o dims)
      (if (equal dims `(1 1))
	  (mgl-mat:mref o 0 0)
	  o))))

(defun reshape-tensor (enable-optimize out x y)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type boolean enable-optimize)
	   (type waffetensor out x y))
  (let ((x1 (decide-out-buffer nil (data x) out enable-optimize)))
    (mgl-mat:reshape! x1 (data y))
    x1))

(declaim (ftype (function (keyword boolean waffetensor waffetensor cons) (or mgl-mat:mat waffedatatype)) dispatch-kernel))
(defun dispatch-kernel (function is-first-time-call? destructable-tensor destructable-tensor1 args)
  (declare (optimize (speed 3) (space 0) (safety 0))
	   (type keyword function)
	   (type boolean is-first-time-call?)
	   (type waffetensor destructable-tensor destructive-tensor1)
	   (type cons args))
  (case function
    (:add    (add-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:sub    (sub-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:mul    (mul-tensor is-first-time-call? destructable-tensor destructable-tensor1 (car args) (second args)))
    (:div    (div-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:inv    (inv-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:dot    (dot-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:matmul (matmul-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:log    (log-tensor is-first-time-call? destructable-tensor (car args)))
    (:exp    (exp-tensor is-first-time-call? destructable-tensor (car args)))
    (:pow    (pow-tensor is-first-time-call? destructable-tensor (car args)))
    (:sqrt   (sqrt-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:sum    (sum-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:mean   (mean-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:tanh    (tanh-tensor is-first-time-call? destructable-tensor (car args)))
    (:reshape (reshape-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:<       (compare-tensor is-first-time-call? destructable-tensor (car args) (second args)))
    (:repeat  (repeat (car args) (third args) :axis (second args)))
    (:transpose (deliv-delay (car args) mgl-mat:transpose))
    (T (error "~a is not yet implemented" ope))))
